<!--
	ES6基础语法：
	1.声明变量：let a=1;(let不会像var那样会发生变量提升);
	2.只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部影响。
	如下代码所示：
	var a=100;
	{	
		在这个代码块里a的值不会收外界影响
		console.log(a);
		let a=200;
		console.log(a);
	}
	3.let不允许重复声明,const声明也不可重复声明
	4.ECMAScript6存在块级作用域，ECMAScript5只存在全局作用域和函数作用域
	6.let命令实际上为Javascript新增了块级作用域
	7.const声明常量：一旦声明常量的值就不能改变(常量一般用大写)

-->
<script type="text/javascript">
	/*
	var a=[];
	for(var i=0;i<5;i++){
		var c=i;
		a[i]=function(){
			console.log(c);
		};
	};
	a[0]();//4,因为执行这个方法时,for()循环早已执行完毕,c的值也已经发生改变
	*/

	/*
	var a=[];
	for(var i=0;i<5;i++){
		let c=i;
		a[i]=function(){
			console.log(c);
		};
	};
	a[0]();//0
	*/

	/*
		var a=100;
		var a=200;
		console.log(a);//200
	*/


	/*
	//报错，模块内部不允许let命令重复声明，但是模块之间不影响，可以重复声明
	var a=100;
	let a=200;
	console.log(a);
	*/



	/*
	var time=new Date();
	function fun(){
		console.log(time);
	}
	fun();
	*/


	/*
	var time=new Date();
	function fun(){
		console.log(time);//undefined,因为if语句中的声明time提前，赋值没有提前,这就是没有块级作用域的不好
		if(false){
			var time="hello";
		}
	}
	fun();
	*/


	/*
	if(true){
		const Pi=3.14;
	}
	console.log(Pi);//报错，说明const也是块级作用域
	*/


	/*
	//const对象
	const person={};
	person.name="zhangsan";
	person.age=18;
	console.log(person.name,person.age,person);//zhangsan 18  {name: "zhangsan", age: 18}
	*/


	/*
	var [a,b,c]=new Set([1,2,3]);
	console.log(a,b,c);//1 2 3
	*/


	/*
	//数组的默认赋值
	let[a=1,b=a]=[];
	console.log(a,b);//1 1
	*/

	/*
	let [a=1,b=a]=[2];
	console.log(a,b);//2 2
	*/


	/*
	默认值是当这个变量没有被赋值的情况下才使用默认值
	let [a=1,b=a]=[2,3];
	console.log(a,b);//2 3
	*/


	/*
	//对象的解构赋值
	let {a,b}={a:1,b:2};//声明的变量名必须和后面对象中的属性名保持一致
	console.log(a,b);//1 2
	*/


	/*
	let {c,b}={a:1,b:2};
	console.log(c,b);//undefined 2
	*/

	/*
	//如果不想变量名跟后面的属性名保持一致，但是也想用后面的值可以采用下面的方法
	let {a:aa,b:bb}={a:1,b:2};
	console.log(a,b);//这样会报错
	*/

	/*
	let {a:aa,b:bb}={a:1,b:2};
	console.log(aa,bb);//1 2 此时就只能用aa 和bb了
	*/


	/*
	let obj={
		a:[ "lysun", {b:"学习"} ]
	};
	//解构复杂的对象
	let{a:[name,{b}]}=obj;
	console.log(name,b);//lysun 学习
	*/


	/*
	//函数参数的解构赋值
	function fn({a,b}){
		console.log([a,b]);//[1 2]
	}
	fn({a:1,b:2});
	*/


	/*
	//参数有默认值
	function fn({a=11,b=22}){
		console.log([a,b]);//这种情况会报错，因为函数调用的时候没有传递任何参数
	}
	fn();//这里不传递任何参数,要想不报错可以像下面代码所写
	*/


	/*
	function fn({a=11,b=22}={}){
		console.log([a,b]);// [11 22]
	}
	fn();
	*/


	/*
	function fn({a=11,b=22}){
		console.log([a,b]);//[5 22]
	}
	fn({a:5});
	*/


	/*
	function fn({a,b}={a:1,b:2}){
		console.log([a,b]);//[1 2],参数没有传值时才会取默认值，一旦传递的参数有一个值，就不会取这里的默认值
	}
	fn();
	*/


	/*
	function fn({a,b}={a:1,b:2}){
		console.log([a,b]);//[11 undefined]
	}
	fn({a:11});
	*/


	/*
	function fn({a,b}={a:1,b:2}){
		console.log([a,b]);//[11 22]
	}
	fn({a:11,b:22});
	*/


	/*
	function fn({a,b}={a:1,b:2}){
		console.log([a,b]);//[undefined undefined]哪怕传递的是一个空对象，也不会取默认值
	}
	fn({});//传递一个空对象
	*/


	/*
	//类 class(ES6里面类的用法)
	class Person{
		say(){
			console.log("i can say!");
		}
	}
	//调用类里面的方法
	var p=new Person();
	p.say();//i can say!
	*/


	/*
	//class 类 constructor构造方法
	class Person{
		//构造方法constructor是在类被实例化以后立刻被调用,它的主要作用是传参
		constructor(name){
			this.name=name;
		}
		say(){
			console.log(this.name+"is study");
		}
	}
	var pp=new Person("lysun");
	pp.say();
	*/


	/*
	class Person{
		constructor(name){
			this.name=name;
		}
		say(){
			console.log(this.name+" is study");
		}
	}
	class Man extends Person{

	}
	var m=new Man();
	m.say();// undefined is study(继承了Person类的say()方法，但是没有name)

	class Woman extends Person{

	}
	var w=new Woman();
	w.say();//undefined is study
	*/



	/*
	class Person{
		constructor(name){
			this.name=name;
		}
		say(){
			console.log(this.name+" is study");
		}
	}
	class Man extends Person{

	}
	var m=new Man("男人");
	m.say();// 男人 is study

	class Woman extends Person{

	}
	var w=new Woman("女人");
	w.say();//女人 is study
	*/


	/*
	class Person{
		constructor(name){
			this.name=name;
		}
		say(){
			console.log(this.name+" is study");
		}
	}
	class Man extends Person{
		constructor(name){
			super(name);
		}
	}
	var m=new Man("男人");
	m.say();// 男人 is study

	class Woman extends Person{

	}
	var w=new Woman("女人");
	w.say();//女人 is study
	*/


	/*
	//class  静态方法
	class Person{
		 static say(name){// 静态方法需要在前面加上关键字 static
			console.log(name);
		}
	}
	Person.say("lysun");//静态方法的调用可以直接用类名+方法名;
	*/



	/*
	//export 输出
	var name="lysun";
	var age=20;
	export{name,age};//输出
	export{name as nn,age};//把name变量名替换为其他变量名用关键词as
	*/


	/*
		整体导出
	//*表示导出所有的变量信息;
	import * as data from "./study";
	console.log(data.name);//把所有的变量信息都存储在变量data里面
	*/


	/*
	//默认导出
	export default  function say(){
		console.log("导出方法成功");
	}

	//导入页面
	import fn from "./study";
	fn();
	*/


	/*
	function fn(...data){
		data.forEach(d=>{
			console.log(d);// 1 2 3
		});
	}
	fn(1,2,3);
	*/



	/*
	var arr=[1,2,3];
	var a=[...arr,4];
	console.log(a);//[1 2 3 4]
	*/


	/*
	function fn(name){
		return name;
	}
	fn("lysun");//lysun
	*/


	/*
	//箭头函数
	var fn=name=>name;//这里面声明的变量fn相当于函数名,箭头左边的name相当于参数名，箭头右边的name是函数的返回值;当只有一个参数的时候可以省略参数name的小括号
	console.log(fn("lysun"));//lysun
	*/


	/*
	var fn=(name,age)=>name+age;//如果参数是多个就不能省略参数的小括号;
	fn("lysun",20);
	*/


	/*
	var fn=(name,age)=>{//如果不只是一个返回值可以加上花括号，然后在花括号里面书写代码;
		return name+age;
	}
	fn("lysun",20);
	*/


	/*
	//Map
	var data=new Map();
	console.log(data);//Map{}
	//set(key,value)添加
	data.set("a",1);
	data.set("b",2);
	data.set("c",3);
	console.log(data);//Map{"a"=>1,"b"=>1,"c"=>1}

	//get(key)获得
	console.log(data.get("a"));//1

	//成员的个数 size
	console.log(data.size);//3

	//删除delete
	data.delete("a");

	//查找has(),查找到则返回true
	console.log(data.has("a"));//false

	//遍历forEach()
	data.forEach((key,value)=>{
		console.log(key+"="+value);
	});
	*/









































	</script>

